<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <link rel="stylesheet" href="../_static/theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/plex/css/ibm-plex.css" type="text/css" />
    <script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.min.js"></script>
    <script src="https://quantumexperience.cdnedge.bluemix.net/ibm-q-navigation/latest/ibm_q_navigation.min.js"></script>
    <link rel="stylesheet" href="https://quantumexperience.cdnedge.bluemix.net/ibm-q-navigation/latest/ibm_q_navigation.css">
    
    <title>Shor’s algorithm &#8212; Full User Guide 2.0 documentation</title>

    <link rel="stylesheet" href="../_static/material-icons.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/material-design-lite-1.3.0/material.blue-indigo.min.css" type="text/css" />
    <link rel="stylesheet" href="../_static/sphinx_materialdesign_theme.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../_static/themeExt.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Quantum Error Correction" href="../005-Quantum_Error_Correction/059-Quantum_Error_Correction.html" />
    <link rel="prev" title="Quantum Phase Estimation" href="100-Quantum_Phase_Estimation.html" /> 
  </head>
<body>
  <div id="q-navigation"></div>
  <script>
  ibm_q_navigation.default.load(
    '#q-navigation', // element selector to put the navigation component
    'IBM Q', // Brand name
    null,
    null,
    true, // should the action buttons (search and signin) be hidden
    true // use absolute paths for all the urls
  );
  </script>
    <div class="mdl-layout mdl-js-layout  mdl-layout--fixed-drawer"><header class="mdl-layout__drawer">
    
          <!-- Title -->
      <span class="mdl-layout-title">
          <a class="title" href="../introduction.html">
              <span class="title-text">
                  Full User Guide
              </span>
          </a>
      </span>
    
    
      <div class="globaltoc">
        <span class="mdl-layout-title toc">Table Of Contents</span>
        
        
            
            <nav class="mdl-navigation">
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../000-FAQ/000-Frequently_Asked_Questions.html">Frequently Asked Questions</a><ul class="simple">
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../001-The_IBM_Q_Experience/001-Introducing_the_IBM_Q_Experience.html">Introducing the IBM Q Experience</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../001-The_IBM_Q_Experience/002-The_Quantum_World.html">The Quantum World</a></li>
<li class="toctree-l2"><a class="reference internal" href="../001-The_IBM_Q_Experience/003-The_Quantum_Composer.html">The Quantum Composer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../001-The_IBM_Q_Experience/004-Running_your_Quantum_Scores.html">Running your Quantum Scores</a></li>
<li class="toctree-l2"><a class="reference internal" href="../001-The_IBM_Q_Experience/005-The_Results.html">The Results</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../002-The_Weird_and_Wonderful_World_of_the_Qubit/000-The_Weird_and_Wonderful_World_of_the_Qubit.html">The Wonderful World of the Qubit</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../002-The_Weird_and_Wonderful_World_of_the_Qubit/001-The_Quantum_Bit_(Qubit).html">The Quantum Bit (Qubit)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../002-The_Weird_and_Wonderful_World_of_the_Qubit/002-Creating_superpositions.html">Creating Superpositions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../002-The_Weird_and_Wonderful_World_of_the_Qubit/003-Introducing_qubit_phase.html">Introducing Qubit Phase</a></li>
<li class="toctree-l2"><a class="reference internal" href="../002-The_Weird_and_Wonderful_World_of_the_Qubit/004-advanced_qubit_gates.html">Advanced Single-Qubit Gates</a></li>
<li class="toctree-l2"><a class="reference internal" href="../002-The_Weird_and_Wonderful_World_of_the_Qubit/005-The_Bloch_Sphere.html">The Bloch Sphere</a></li>
<li class="toctree-l2"><a class="reference internal" href="../002-The_Weird_and_Wonderful_World_of_the_Qubit/006-Decoherence.html">Decoherence</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../003-Multiple_Qubits_Gates_and_Entangled_States/000-Multiple_Qubits_Gates_and_Entangled_States.html">Multi-Qubit Gates and Entangled States</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../003-Multiple_Qubits_Gates_and_Entangled_States/001-Multiple_Qubits.html">Multiple Qubits</a></li>
<li class="toctree-l2"><a class="reference internal" href="../003-Multiple_Qubits_Gates_and_Entangled_States/002-Entanglement_and_Bell_Tests.html">Entanglement and Bell Tests</a></li>
<li class="toctree-l2"><a class="reference internal" href="../003-Multiple_Qubits_Gates_and_Entangled_States/003-GHZ_States.html">GHZ States</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="060-Quantum_Algorithms.html">Quantum Algorithms</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="061-Basic_Circuit_Identities_and_Larger_Circuits.html">Basic Circuit Identities and Larger Circuits</a></li>
<li class="toctree-l2"><a class="reference internal" href="070-Grover's_Algorithm.html">Grover’s Algorithm</a></li>
<li class="toctree-l2"><a class="reference internal" href="080-Deutsch-Jozsa_Algorithm.html">Deutsch-Jozsa Algorithm</a></li>
<li class="toctree-l2"><a class="reference internal" href="081-Learning_Parity_with_Noise.html">Learning Parity with Noise</a></li>
<li class="toctree-l2"><a class="reference internal" href="100-Quantum_Phase_Estimation.html">Quantum Phase Estimation</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Shor’s algorithm</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../005-Quantum_Error_Correction/059-Quantum_Error_Correction.html">Quantum Error Correction</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../005-Quantum_Error_Correction/060-Quantum_Repetition_Code.html">Quantum Repetition Code</a></li>
<li class="toctree-l2"><a class="reference internal" href="../005-Quantum_Error_Correction/061-Stabilizer_Measurements.html">Stabilizer Measurements</a></li>
</ul>
</li>
</ul>

            </nav>
        
        </div>
    
</header>
        <main class="mdl-layout__content" tabIndex="0">
<header class="mdl-layout__drawer">
    
          <!-- Title -->
      <span class="mdl-layout-title">
          <a class="title" href="../introduction.html">
              <span class="title-text">
                  Full User Guide
              </span>
          </a>
      </span>
    
    
      <div class="globaltoc">
        <span class="mdl-layout-title toc">Table Of Contents</span>
        
        
            
            <nav class="mdl-navigation">
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../000-FAQ/000-Frequently_Asked_Questions.html">Frequently Asked Questions</a><ul class="simple">
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../001-The_IBM_Q_Experience/001-Introducing_the_IBM_Q_Experience.html">Introducing the IBM Q Experience</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../001-The_IBM_Q_Experience/002-The_Quantum_World.html">The Quantum World</a></li>
<li class="toctree-l2"><a class="reference internal" href="../001-The_IBM_Q_Experience/003-The_Quantum_Composer.html">The Quantum Composer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../001-The_IBM_Q_Experience/004-Running_your_Quantum_Scores.html">Running your Quantum Scores</a></li>
<li class="toctree-l2"><a class="reference internal" href="../001-The_IBM_Q_Experience/005-The_Results.html">The Results</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../002-The_Weird_and_Wonderful_World_of_the_Qubit/000-The_Weird_and_Wonderful_World_of_the_Qubit.html">The Wonderful World of the Qubit</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../002-The_Weird_and_Wonderful_World_of_the_Qubit/001-The_Quantum_Bit_(Qubit).html">The Quantum Bit (Qubit)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../002-The_Weird_and_Wonderful_World_of_the_Qubit/002-Creating_superpositions.html">Creating Superpositions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../002-The_Weird_and_Wonderful_World_of_the_Qubit/003-Introducing_qubit_phase.html">Introducing Qubit Phase</a></li>
<li class="toctree-l2"><a class="reference internal" href="../002-The_Weird_and_Wonderful_World_of_the_Qubit/004-advanced_qubit_gates.html">Advanced Single-Qubit Gates</a></li>
<li class="toctree-l2"><a class="reference internal" href="../002-The_Weird_and_Wonderful_World_of_the_Qubit/005-The_Bloch_Sphere.html">The Bloch Sphere</a></li>
<li class="toctree-l2"><a class="reference internal" href="../002-The_Weird_and_Wonderful_World_of_the_Qubit/006-Decoherence.html">Decoherence</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../003-Multiple_Qubits_Gates_and_Entangled_States/000-Multiple_Qubits_Gates_and_Entangled_States.html">Multi-Qubit Gates and Entangled States</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../003-Multiple_Qubits_Gates_and_Entangled_States/001-Multiple_Qubits.html">Multiple Qubits</a></li>
<li class="toctree-l2"><a class="reference internal" href="../003-Multiple_Qubits_Gates_and_Entangled_States/002-Entanglement_and_Bell_Tests.html">Entanglement and Bell Tests</a></li>
<li class="toctree-l2"><a class="reference internal" href="../003-Multiple_Qubits_Gates_and_Entangled_States/003-GHZ_States.html">GHZ States</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="060-Quantum_Algorithms.html">Quantum Algorithms</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="061-Basic_Circuit_Identities_and_Larger_Circuits.html">Basic Circuit Identities and Larger Circuits</a></li>
<li class="toctree-l2"><a class="reference internal" href="070-Grover's_Algorithm.html">Grover’s Algorithm</a></li>
<li class="toctree-l2"><a class="reference internal" href="080-Deutsch-Jozsa_Algorithm.html">Deutsch-Jozsa Algorithm</a></li>
<li class="toctree-l2"><a class="reference internal" href="081-Learning_Parity_with_Noise.html">Learning Parity with Noise</a></li>
<li class="toctree-l2"><a class="reference internal" href="100-Quantum_Phase_Estimation.html">Quantum Phase Estimation</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Shor’s algorithm</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../005-Quantum_Error_Correction/059-Quantum_Error_Correction.html">Quantum Error Correction</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../005-Quantum_Error_Correction/060-Quantum_Repetition_Code.html">Quantum Repetition Code</a></li>
<li class="toctree-l2"><a class="reference internal" href="../005-Quantum_Error_Correction/061-Stabilizer_Measurements.html">Stabilizer Measurements</a></li>
</ul>
</li>
</ul>

            </nav>
        
        </div>
    
</header>

    <div class="document">
        <div class="page-content">
        
  <div class="section" id="shor-s-algorithm">
<h1>Shor’s algorithm<a class="headerlink" href="#shor-s-algorithm" title="Permalink to this headline">¶</a></h1>
<div class="line-block">
<div class="line">Although any integer number has a unique decomposition into a product
of primes, finding the prime factors is believed to be a hard&nbsp;problem.
In fact, the security of our online transactions rests on the
assumption that&nbsp;factoring integers with a thousand or more digits is
practically impossible.&nbsp;This assumption has been challenged in 1995
when Peter Shor proposed a polynomial-time quantum&nbsp;algorithm for the
factoring problem. Shor’s algorithm is arguably the most dramatic
example of how the paradigm of quantum computing changed our
perception of which problems should be considered tractable. In this
section we briefly summarize some basic facts about factoring,
highlight&nbsp;main ingredients of the Shor’s algorithm,&nbsp;and illustrate how
it works using a toy factoring problem.</div>
</div>
<div class="section" id="complexity-of-factoring">
<h2><strong>Complexity of factoring</strong>.<a class="headerlink" href="#complexity-of-factoring" title="Permalink to this headline">¶</a></h2>
<p>Suppose our task is to factor an integer <span class="math notranslate nohighlight">\(N\)</span> with <span class="math notranslate nohighlight">\(d\)</span> decimal
digits. The brute force algorithm&nbsp;goes through all primes <span class="math notranslate nohighlight">\(p\)</span> up to
<span class="math notranslate nohighlight">\(\sqrt{N}\)</span> and checks whether <span class="math notranslate nohighlight">\(p\)</span> divides <span class="math notranslate nohighlight">\(N\)</span>.&nbsp;In the worst case,
this would take time roughly <span class="math notranslate nohighlight">\(\sqrt{N}\)</span> which is exponential in the
number of digits <span class="math notranslate nohighlight">\(d\)</span>. &nbsp;A more efficient algorithm known as the
quadratic sieve attempts to construct integers <span class="math notranslate nohighlight">\(a,b\)</span> such that
<span class="math notranslate nohighlight">\(a^2-b^2\)</span> is a multiple of <span class="math notranslate nohighlight">\(N\)</span>.&nbsp;Once such <span class="math notranslate nohighlight">\(a,b\)</span> are found, one
checks whether <span class="math notranslate nohighlight">\(a\pm b\)</span> have common factors with <span class="math notranslate nohighlight">\(N\)</span>. &nbsp;The
quadratic sieve method has asymptotic runtime exponential in
<span class="math notranslate nohighlight">\(\sqrt{d}\)</span>. The most efficient classical factoring algorithm known as
general number field sieve&nbsp;achieves an asymptotic runtime exponential in
<span class="math notranslate nohighlight">\(d^{1/3}\)</span>. &nbsp;The exponential runtime scaling limits applicability of
the classical factoring algorithms&nbsp;to numbers with a few hundred digits
&nbsp;with the world record being <span class="math notranslate nohighlight">\(d=232\)</span> (which took roughly 2,000 CPU
years). &nbsp;In contrast, Shor’s factoring algorithm has runtime
<em>polynomial</em> in <span class="math notranslate nohighlight">\(d\)</span>. The&nbsp;version of the algorithm described below due
to Alexey Kitaev&nbsp;requires roughly <span class="math notranslate nohighlight">\(10d\)</span> qubits and has runtime
&nbsp;roughly <span class="math notranslate nohighlight">\(d^3\)</span>.</p>
<p><img alt="image0" src="https://dal.objectstorage.open.softlayer.com/v1/AUTH_039c3bf6e6e54d76b8e66152e2f87877/images-classroom/shor-figure1l0qpbqeb138fr.png" />&nbsp; &nbsp; **&nbsp;**</p>
<div class="line-block">
<div class="line"><strong>Figure 1: classical vs quantum factoring algorithms</strong></div>
</div>
</div>
<div class="section" id="period-finding">
<h2><strong>Period finding</strong>.﻿﻿ ﻿<a class="headerlink" href="#period-finding" title="Permalink to this headline">¶</a></h2>
<p>It has been known to mathematicians since 1970’s that factoring becomes
easy if one can solve another hard problem: find a period&nbsp;of the modular
exponential function. The period finding problem is defined as
follows.&nbsp;Given integers <span class="math notranslate nohighlight">\(N\)</span> and <span class="math notranslate nohighlight">\(a\)</span>, find the smallest positive
integer <span class="math notranslate nohighlight">\(r\)</span> &nbsp;such that <span class="math notranslate nohighlight">\(a^r-1\)</span> is a multiple of <span class="math notranslate nohighlight">\(N\)</span>. The number
<span class="math notranslate nohighlight">\(r\)</span> is called the period of <span class="math notranslate nohighlight">\(a\)</span> modulo <span class="math notranslate nohighlight">\(N\)</span>.&nbsp;Recall that in modular
arithmetics the remainder of a division <span class="math notranslate nohighlight">\(a/N\)</span> is called the value of
<span class="math notranslate nohighlight">\(a\)</span> modulo <span class="math notranslate nohighlight">\(N\)</span> and denoted <span class="math notranslate nohighlight">\(a\pmod{N}\)</span>. For example, <span class="math notranslate nohighlight">\(1=16=91
\pmod{15}\)</span>. Thus the period of <span class="math notranslate nohighlight">\(a\)</span> modulo <span class="math notranslate nohighlight">\(N\)</span> is the smallest
positive integer <span class="math notranslate nohighlight">\(r\)</span> such that <span class="math notranslate nohighlight">\(a^r=1{\pmod N}\)</span>. For example,
suppose <span class="math notranslate nohighlight">\(N=15\)</span> and <span class="math notranslate nohighlight">\(a=7\)</span>. Then</p>
<div class="line-block">
<div class="line"><img alt="image1" src="https://dal.objectstorage.open.softlayer.com/v1/AUTH_039c3bf6e6e54d76b8e66152e2f87877/images-classroom/shor-equation3fjaulqz4sqe3766r.png" /></div>
</div>
<p>that is, <span class="math notranslate nohighlight">\(7\)</span> has period <span class="math notranslate nohighlight">\(4\)</span> modulo <span class="math notranslate nohighlight">\(15\)</span>. Note that computing the
higher powers of <span class="math notranslate nohighlight">\(7\)</span> would give rise to a periodic sequence:
<span class="math notranslate nohighlight">\(7^{x+4}=7^x\pmod{15}\)</span> for any integer <span class="math notranslate nohighlight">\(x\)</span>. Thus <span class="math notranslate nohighlight">\(r=4\)</span> is the
period of the modular exponential function <span class="math notranslate nohighlight">\(7^x\)</span>. &nbsp;In general the
period finding problem is well-defined if <span class="math notranslate nohighlight">\(N\)</span> and <span class="math notranslate nohighlight">\(a\)</span> are co-prime
(have no common factors).</p>
</div>
<div class="section" id="from-factoring-to-period-finding">
<h2><strong>From factoring to period finding</strong>.<a class="headerlink" href="#from-factoring-to-period-finding" title="Permalink to this headline">¶</a></h2>
<p>Assume for a moment that we are given a period finding machine that
takes as input co-prime integers <span class="math notranslate nohighlight">\(N,a\)</span> and outputs the period of <span class="math notranslate nohighlight">\(a\)</span>
modulo <span class="math notranslate nohighlight">\(N\)</span>. Let us show how to use the machine to find all prime
factors of <span class="math notranslate nohighlight">\(N\)</span>. For simplicity, assume that <span class="math notranslate nohighlight">\(N\)</span> has only two
distinct prime factors:</p>
<div class="line-block">
<div class="line"><img alt="image2" src="https://dal.objectstorage.open.softlayer.com/v1/AUTH_039c3bf6e6e54d76b8e66152e2f87877/images-classroom/shor-equation21ma2bwliskjd1jor.png" /></div>
</div>
<p>First, pick a random integer <span class="math notranslate nohighlight">\(a\)</span> between <span class="math notranslate nohighlight">\(2\)</span> and <span class="math notranslate nohighlight">\(N-1\)</span>&nbsp;and compute
the greatest common divisor gcd:math:<cite>(N,a)</cite>.&nbsp;This can be done very
efficiently using <a class="reference external" href="http://en.wikipedia.org/wiki/Euclidean_algorithm">Euclid’s
algorithm</a>.&nbsp;If we
are lucky, <span class="math notranslate nohighlight">\(N\)</span> and <span class="math notranslate nohighlight">\(a\)</span> have some common prime factors&nbsp;in which case
gcd:math:<cite>(N,a)</cite> equals <span class="math notranslate nohighlight">\(p_1\)</span> or <span class="math notranslate nohighlight">\(p_2\)</span>, so we are done.&nbsp;From now on
let us assume that gcd:math:<cite>(N,a)=1</cite>, that is, <span class="math notranslate nohighlight">\(N\)</span> and <span class="math notranslate nohighlight">\(a\)</span> are
co-prime.&nbsp;Let <span class="math notranslate nohighlight">\(r\)</span> be the period of <span class="math notranslate nohighlight">\(a\)</span> modulo <span class="math notranslate nohighlight">\(N\)</span> computed by the
machine.&nbsp;Repeat the above steps with different random choices of <span class="math notranslate nohighlight">\(a\)</span>
until <span class="math notranslate nohighlight">\(r\)</span> is even. &nbsp;It can be shown that a significant fraction of all
integers <span class="math notranslate nohighlight">\(a\)</span> &nbsp;has even period,&nbsp;see Table 1 for examples, so on average
one needs only a few repetitions. &nbsp;At this point we have found some pair
<span class="math notranslate nohighlight">\(r,a\)</span>&nbsp;such that <span class="math notranslate nohighlight">\(r\)</span> is even and <span class="math notranslate nohighlight">\(r\)</span> is the smallest integer such
that <span class="math notranslate nohighlight">\(a^r-1\)</span> is a multiple of <span class="math notranslate nohighlight">\(N\)</span>.&nbsp;Let us use the identity</p>
<div class="line-block">
<div class="line"><img alt="image3" src="https://dal.objectstorage.open.softlayer.com/v1/AUTH_039c3bf6e6e54d76b8e66152e2f87877/images-classroom/shor-equation1vm27qee4bcma38fr.png" /></div>
</div>
<div class="line-block">
<div class="line">The above shows that <span class="math notranslate nohighlight">\(a^{r/2}-1\)</span> is not a multiple of <span class="math notranslate nohighlight">\(N\)</span>
(otherwise the period of <span class="math notranslate nohighlight">\(a\)</span> would be <span class="math notranslate nohighlight">\(r/2\)</span>). Assume for a moment
that <span class="math notranslate nohighlight">\(a^{r/2}+1\)</span> is not a multiple of <span class="math notranslate nohighlight">\(N\)</span>.&nbsp;Then neither of the
integers <span class="math notranslate nohighlight">\(a^{r/2}\pm 1\)</span>&nbsp;is a multiple of <span class="math notranslate nohighlight">\(N\)</span>, but their product
is. &nbsp;This is possible only if <span class="math notranslate nohighlight">\(p_1\)</span> is a prime factor of
<span class="math notranslate nohighlight">\(a^{r/2}-1\)</span>&nbsp;and <span class="math notranslate nohighlight">\(p_2\)</span> is a prime factor of <span class="math notranslate nohighlight">\(a^{r/2}+1\)</span> (or vice
verse).&nbsp;Thus we can find <span class="math notranslate nohighlight">\(p_1\)</span> and <span class="math notranslate nohighlight">\(p_2\)</span> by computing
gcd:math:<cite>(N,a^{r/2}pm 1)</cite>, see Table 1 for examples. &nbsp;In the remaining
``unlucky” case when <span class="math notranslate nohighlight">\(a^{r/2}+1\)</span> is a multiple of <span class="math notranslate nohighlight">\(N\)</span>&nbsp;we give up
and try a different integer <span class="math notranslate nohighlight">\(a\)</span>. &nbsp;For example, <span class="math notranslate nohighlight">\(a=14\)</span> is the only
unlucky integer in Table 1.&nbsp;In general, &nbsp;it can be shown that the
unlucky integers <span class="math notranslate nohighlight">\(a\)</span> are not too frequent, so on average only two
calls to the period finding machine&nbsp;are sufficient to factor <span class="math notranslate nohighlight">\(N\)</span>.</div>
</div>
<div class="line-block">
<div class="line"><img alt="image4" src="https://dal.objectstorage.open.softlayer.com/v1/AUTH_039c3bf6e6e54d76b8e66152e2f87877/images-classroom/shor-table9nl8715xk3d3rf6r.png" /></div>
<div class="line"><strong>Table 1: period of integers :math:`a` modulo :math:`15`</strong></div>
</div>
</div>
<div class="section" id="id1">
<h2><strong>Shor’s algorithm</strong>.<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<div class="line-block">
<div class="line">Let us now show that a quantum computer can efficiently simulate&nbsp;the
period finding machine. &nbsp;As in the case of the<a class="reference external" href="../004-Quantum_Algorithms/080-Deutsch-Jozsa_Algorithm.html">Deutsch-Jozsa
algorithm</a>,
we shall exploit quantum parallelism and constructive interference to
determine whether a complicated function has a certain&nbsp;global property
that cannot be learned by evaluating the function only at a few
points.&nbsp;However, instead of detecting the property of being a balanced
function, we seek to detect and measure&nbsp;periodicity of the modular
exponentiation function. The fact that interference makes it easier to
measure&nbsp;periodicity should not come as a big surprise. After all,
physicists routinely use scattering of electromagnetic waves&nbsp;and
interference measurements to determine periodicity of physical objects
such as crystal lattices. Likewise, Shor’s algorithm exploits
interference to measure periodicity of arithmetic objects.</div>
</div>
<p>Suppose we are given co-prime integers <span class="math notranslate nohighlight">\(a,N\)</span>. Our goal is compute the
period of <span class="math notranslate nohighlight">\(a\)</span>&nbsp;modulo <span class="math notranslate nohighlight">\(N\)</span>, that is, the smallest positive integer
<span class="math notranslate nohighlight">\(r\)</span> such that <span class="math notranslate nohighlight">\(a^r=1\pmod{N}\)</span>.&nbsp;The basic idea is to construct a
unitary operator <span class="math notranslate nohighlight">\(U_a\)</span> that implements the modular
multiplication&nbsp;function <span class="math notranslate nohighlight">\(x\to ax \pmod{N}\)</span>. It can be shown that
eigenvalues of <span class="math notranslate nohighlight">\(U_a\)</span> are closely related to the period of <span class="math notranslate nohighlight">\(a\)</span>.
Namely, each eigenvalue of <span class="math notranslate nohighlight">\(U_a\)</span> has a form <span class="math notranslate nohighlight">\(e^{i\phi}\)</span>, where
<span class="math notranslate nohighlight">\(\phi=2\pi k/r\)</span>&nbsp;for some integer <span class="math notranslate nohighlight">\(k\)</span>. Furthermore, as we saw in
the previous section, eigenvalues of certain unitary operators can be
measured efficiently using the phase estimation
algorithm.&nbsp;Unfortunately, inferring <span class="math notranslate nohighlight">\(r\)</span> from the measured eigenvalues
of <span class="math notranslate nohighlight">\(U_a\)</span>&nbsp;is only possible if the eigenvalues are measured <em>exactly</em>
(or with an exponentially small precision).&nbsp;For example, factoring a
1,000-digit number would require measuring the eigenvalue of <span class="math notranslate nohighlight">\(U_a\)</span>
with a precision <span class="math notranslate nohighlight">\(10^{-2000}\)</span>.&nbsp;Such accuracy cannot be achieved by a
direct application of the phase estimation algorithm&nbsp;as this would
require too large pointer system.&nbsp;Here comes the main trick: we shall
estimate the eigenvalue of <span class="math notranslate nohighlight">\(U_a\)</span> by&nbsp;applying&nbsp;the phase estimation
algorithm to a family of unitary operators <span class="math notranslate nohighlight">\(U_b\)</span>&nbsp;with
<span class="math notranslate nohighlight">\(b=a,a^2,a^4,a^8\)</span> etc.&nbsp;We stop at <span class="math notranslate nohighlight">\(b=a^{2^p}\)</span> with <span class="math notranslate nohighlight">\(2^p\approx
N^2\)</span>.&nbsp;Why does it work? The first observation is that &nbsp;all operators
<span class="math notranslate nohighlight">\(U_b\)</span> are integer powers of <span class="math notranslate nohighlight">\(U_a\)</span>.&nbsp;Namely, if <span class="math notranslate nohighlight">\(b=a^t\)</span> then
<span class="math notranslate nohighlight">\(U_b=(U_a)^t\)</span>.&nbsp;This implies that the operators <span class="math notranslate nohighlight">\(U_b\)</span>&nbsp;&nbsp;have the
same eigenvectors.&nbsp;In particular, eigenvalues of the entire family
<span class="math notranslate nohighlight">\(U_b\)</span>&nbsp;can be measured simultaneously. &nbsp;Second, implementing <span class="math notranslate nohighlight">\(U_b\)</span>
is as easy as implementing <span class="math notranslate nohighlight">\(U_a\)</span> - one just need&nbsp;to precompute the
powers <span class="math notranslate nohighlight">\(b=a,a^2,a^4,a^8,\ldots \pmod{N}\)</span> by the repeated squaring
method.&nbsp;Finally, even if the eigenvalues of <span class="math notranslate nohighlight">\(U_b\)</span> are measured with a
poor precision (say 10%),&nbsp;each squaring of <span class="math notranslate nohighlight">\(a\)</span> reduces the error in
the estimated eigenvalue of <span class="math notranslate nohighlight">\(U_a\)</span> by&nbsp;a factor <span class="math notranslate nohighlight">\(1/2\)</span>. &nbsp;Indeed,
consider an eigenvector of <span class="math notranslate nohighlight">\(U_a\)</span> with an eigenvalue
<span class="math notranslate nohighlight">\(e^{i\phi}\)</span>.&nbsp;If <span class="math notranslate nohighlight">\(b=a^2\)</span> then the eigenvalue of <span class="math notranslate nohighlight">\(U_b\)</span> is
<span class="math notranslate nohighlight">\(e^{2i\phi}\)</span>. If <span class="math notranslate nohighlight">\(b=a^4\)</span> then the&nbsp;eigenvalue of <span class="math notranslate nohighlight">\(U_b\)</span> &nbsp;is
<span class="math notranslate nohighlight">\(e^{4i\phi}\)</span> etc. Thus we can estimate
<span class="math notranslate nohighlight">\(\phi,2\phi,4\phi,\ldots,2^p\phi\)</span> with a constant precision (say
10%). We shall see that this&nbsp;is enough to estimate <span class="math notranslate nohighlight">\(\phi\)</span> with a
precision roughly <span class="math notranslate nohighlight">\(2^{-p}\)</span>. &nbsp;For example, &nbsp;one can achieve a precision
<span class="math notranslate nohighlight">\(10^{-2000}\)</span>&nbsp;by a sequence of less than <span class="math notranslate nohighlight">\(10^6\)</span> &nbsp;lousy measurements
of <span class="math notranslate nohighlight">\(U_b\)</span> with an error 10%. Furthermore, it can be shown that
estimating a few randomly picked eigenvalues&nbsp;<span class="math notranslate nohighlight">\(\phi=2\pi k/r\)</span> with a
precision less than <span class="math notranslate nohighlight">\(1/N^2\)</span> is enough to determine the period <span class="math notranslate nohighlight">\(r\)</span>
exactly (the idea is to find the best rational approximation to the
estimate of <span class="math notranslate nohighlight">\(k/r\)</span> using continued fractions).</p>
<p>In order to use the phase estimation algorithm we need to construct a
quantum circuit implementing the modular multiplication operator. By
analogy with classical algorithms that can link standard library
functions, a quantum algorithm is allowed to call classical subroutines,
for example a subroutine for computing the modular multiplication.
Importantly, before such classical subroutines are incorporated into a
quantum circuit, they must be transformed into a <em>reversible
form.</em>More precisely, a quantum algorithm can call a classical
subroutine only if it is compiled into a sequence of reversible logical
gates such as CNOT or Toffoli gate (in particular, the number of input
and output wires in each gate must be the same). The&nbsp;subroutine is
allowed to use a scratch memory similar to local variables used by the
standard library functions. However, once the subroutine is completed,
the scratch memory must be totally clean (say, all zeros).&nbsp;The reason is
that a quantum algorithm operates on coherent superpositions of
different classical states. Leaving information about the inputs or the
outputs in the scratch memory could potentially destroy quantum
coherence and prevent the algorithm from seeing interference between
different states. Since the notion of reversible classical circuits
&nbsp;plays an important role in the Shor’s algorithm and many other quantum
algorithms, below we briefly discuss methods for constructing such
circuits.</p>
</div>
<div class="section" id="reversible-classical-circuits">
<h2><strong>Reversible classical circuits</strong>.<a class="headerlink" href="#reversible-classical-circuits" title="Permalink to this headline">¶</a></h2>
<div class="line-block">
<div class="line">An important insight made in 1973 by our IBM colleague Charles Bennett
is that any classical computation can be transformed into a reversible
form.&nbsp;How does it work?&nbsp;Suppose <span class="math notranslate nohighlight">\(f(x)\)</span> represents some classical
computation that takes&nbsp;as input <span class="math notranslate nohighlight">\(n\)</span>-bit strings <span class="math notranslate nohighlight">\(x\)</span> and outputs
<span class="math notranslate nohighlight">\(m\)</span>-bit strings <span class="math notranslate nohighlight">\(f(x)\)</span>. The first observation is that the answer
<span class="math notranslate nohighlight">\(f(x)\)</span>&nbsp;can be computed without erasing any intermediate data if we
are allowed to use some extra memory. Indeed, let us write down an
algorithm for computing <span class="math notranslate nohighlight">\(f(x)\)</span> and compile it into a sequence of
elementary&nbsp;logical gates such as AND, OR, etc. For concreteness,
assume that each gate has two input wires and one output wire. &nbsp;Let
<span class="math notranslate nohighlight">\(L\)</span> be the total number of gates. We shall extend the <span class="math notranslate nohighlight">\(n\)</span>-bit
memory storing the input <span class="math notranslate nohighlight">\(x\)</span> by adding <span class="math notranslate nohighlight">\(L\)</span> bits initialized by
zeros. These extra bits will serve as a scratch memory for storing
intermediate data.&nbsp;We shall write the output of the &nbsp;<span class="math notranslate nohighlight">\(i\)</span>-th gate to
the <span class="math notranslate nohighlight">\(i\)</span>-th bit of the scratch memory and keep the values of
the&nbsp;input bits. Once the computation is completed, the final answer
<span class="math notranslate nohighlight">\(f(x)\)</span> is contained in some designated output register within the
scratch memory. The remaining part of the scratch memory contains some
“garbage” bit string <span class="math notranslate nohighlight">\(g(x)\)</span> (intermediate data). &nbsp;Below we
illustrate how it works for the example when <span class="math notranslate nohighlight">\(f(x)\)</span> computes the
3-bit Majority function.</div>
</div>
<div class="line-block">
<div class="line"><img alt="image5" src="https://dal.objectstorage.open.softlayer.com/v1/AUTH_039c3bf6e6e54d76b8e66152e2f87877/images-classroom/majority-example6x8rb37gj64dkj4i.png" /></div>
</div>
<p>At this point the circuit is reversible as a whole, but its individual
gates are still irreversible. The next step is to transform each gate
into a reversible form. Consider as an example the AND gate with input
wires <span class="math notranslate nohighlight">\(a,b\)</span> and output wire <span class="math notranslate nohighlight">\(c\)</span> such that <span class="math notranslate nohighlight">\(c=a\wedge b\)</span>. Let us
define its reversible version R-AND. One of the output wires of R-AND
must carry the output bit <span class="math notranslate nohighlight">\(c\)</span> of the standard AND gate. To avoid
losing information, R-AND must have at least two other output wires
(note that in the case <span class="math notranslate nohighlight">\(c=0\)</span> there are three possible input strings:
<span class="math notranslate nohighlight">\(ab=00,01,10\)</span>). The simplest version of R-AND has three input wires
and three output wires as shown below.</p>
<div class="line-block">
<div class="line"><img alt="image6" src="https://dal.objectstorage.open.softlayer.com/v1/AUTH_039c3bf6e6e54d76b8e66152e2f87877/images-classroom/and-circuit2u342pzqqlnv1jor.png" /></div>
</div>
<p>Here <span class="math notranslate nohighlight">\(d\)</span> is a dummy input wire and <span class="math notranslate nohighlight">\(\oplus\)</span> denotes XOR operation
(addition modulo two). The gate expects to receive inputs with <span class="math notranslate nohighlight">\(d=0\)</span>
in which case <span class="math notranslate nohighlight">\(c=a\wedge b\)</span>. If <span class="math notranslate nohighlight">\(d=1\)</span> then the output data bit if
flipped. Note that all inputs of R-AND can be computed from its outputs
since <span class="math notranslate nohighlight">\(d=c\oplus (a\wedge b)\)</span>. Thus R-AND indeed acts reversibly
(technically, R-AND realizes a permutation on the set of 3-bit strings).
Note also that R-AND coincides with the <a class="reference external" href="../004-Quantum_Algorithms/061-Basic_Circuit_Identities_and_Larger_Circuits.html">Toffoli
gate</a>.
The same construction can be applied to any other gate with two input
wires and one output wire. Namely, if a gate F computes some Boolean
function <span class="math notranslate nohighlight">\(c=F(a,b)\)</span> then its reversible version R-F would map inputs
<span class="math notranslate nohighlight">\(a,b,d\)</span> to outputs <span class="math notranslate nohighlight">\(a,b,c\)</span> where <span class="math notranslate nohighlight">\(c=d\oplus F(a,b)\)</span>, see below.
Note that applying R-F twice implements the identity gate, that is, R-F
coincides with its own inverse.</p>
<div class="line-block">
<div class="line"><img alt="image7" src="https://dal.objectstorage.open.softlayer.com/v1/AUTH_039c3bf6e6e54d76b8e66152e2f87877/images-classroom/rgatearl3s2mvkon4gqfr.png" /></div>
</div>
<p>Suppose the original circuit is described by a sequence of <span class="math notranslate nohighlight">\(L\)</span> gates
<span class="math notranslate nohighlight">\(F_1,\ldots,F_L\)</span>. Replace each gate &nbsp;<span class="math notranslate nohighlight">\(F_i\)</span> &nbsp;by its reversible
version <span class="math notranslate nohighlight">\(G_i=R\)</span>-<span class="math notranslate nohighlight">\(F_i\)</span> constructed above. &nbsp;We shall connect the
dummy input wire of <span class="math notranslate nohighlight">\(G_i\)</span> and its output wire <span class="math notranslate nohighlight">\(c\)</span> to the <span class="math notranslate nohighlight">\(i\)</span>-th
bit of the scratch memory such that the gate always receives inputs with
<span class="math notranslate nohighlight">\(d=0\)</span>. The new circuit has <span class="math notranslate nohighlight">\(n+L\)</span> input and <span class="math notranslate nohighlight">\(n+L\)</span> output wires and
is composed from reversible <span class="math notranslate nohighlight">\(3\)</span>-bit gates. The final state generated
by the circuit&nbsp;can be written as <span class="math notranslate nohighlight">\(x,g(x),f(x)\)</span>, where&nbsp;<span class="math notranslate nohighlight">\(f(x)\)</span> is the
final answer stored in the output register somewhere within the&nbsp;scratch
memory and <span class="math notranslate nohighlight">\(g(x)\)</span>&nbsp;represents ``garbage”&nbsp;(intermediate data). Here we
assumed that the scratch memory is initially clean (all zeros). Thus we
have constructed a reversible circuit&nbsp;that maps <span class="math notranslate nohighlight">\(x,0^L\)</span> to
<span class="math notranslate nohighlight">\(x,g(x),f(x)\)</span>. The final step is&nbsp;to get rid of the garbage <span class="math notranslate nohighlight">\(g(x)\)</span>
without erasing any information&nbsp;(which would render the circuit
irreversible).&nbsp;A solution is to copy the answer <span class="math notranslate nohighlight">\(f(x)\)</span> to a clean
ancillary register of <span class="math notranslate nohighlight">\(m\)</span> bits and then ``uncompute” <span class="math notranslate nohighlight">\(f(x)\)</span>&nbsp;by
applying the circuit backwards in time.&nbsp;Below we sketch how this works.</p>
<p>&nbsp;<img alt="image8" src="https://dal.objectstorage.open.softlayer.com/v1/AUTH_039c3bf6e6e54d76b8e66152e2f87877/images-classroom/uncomputel5yqmeuw09gam7vi.png" /></p>
<p>Ignoring for&nbsp;simplicity all ancillary bits &nbsp;that are initialized and
returned in the zero state, we obtained a reversible circuit on <span class="math notranslate nohighlight">\(n+m\)</span>
bits that maps input strings <span class="math notranslate nohighlight">\(x,y\)</span> to output strings <span class="math notranslate nohighlight">\(x,y\oplus
f(x)\)</span>. In the special case when the <span class="math notranslate nohighlight">\(f(x)\)</span> is invertible one can use
similar tricks to &nbsp;construct a reversible circuit that maps input
strings <span class="math notranslate nohighlight">\(x\)</span> to output strings <span class="math notranslate nohighlight">\(f(x)\)</span>. &nbsp;In practice, one would never
use the method described above since it requires too large scratch
memory. Several optimization techniques for constructing reversible
circuits have been proposed (such as uncomputing partial results more
often and reusing scratch memory bits).</p>
</div>
<div class="section" id="quantum-circuits-for-modular-multiplication">
<h2><strong>Quantum circuits for modular multiplication</strong>.<a class="headerlink" href="#quantum-circuits-for-modular-multiplication" title="Permalink to this headline">¶</a></h2>
<p>Suppose now that &nbsp;<span class="math notranslate nohighlight">\(f(x)=ax\pmod{N}\)</span> is the modular multiplication
function. Let <span class="math notranslate nohighlight">\(n\)</span> be the number of binary digits in <span class="math notranslate nohighlight">\(N\)</span>. Using
<span class="math notranslate nohighlight">\(n\)</span>-bit strings to represent integers modulo <span class="math notranslate nohighlight">\(N\)</span>, one can implement
&nbsp;<span class="math notranslate nohighlight">\(f(x)\)</span> by a classical circuit <span class="math notranslate nohighlight">\(U_a\)</span> composed of 3-bit reversible
gates with <span class="math notranslate nohighlight">\(n\)</span> input and output wires, as described above. The circuit
<span class="math notranslate nohighlight">\(U_a\)</span> may also use ancillary bits that are initialized and returned
in the 0 state. The state-of-the-art implementation would require
roughly <span class="math notranslate nohighlight">\(n^2\)</span> gates and&nbsp;roughly <span class="math notranslate nohighlight">\(2n\)</span> ancillary bits. For simplicity,
below we shall often ignore the ancillary bits. &nbsp;Let us convert <span class="math notranslate nohighlight">\(U_a\)</span>
to a quantum circuit &nbsp;by replacing each classical gate with its quantum
counterpart. This is possible because, by construction, each gate of
<span class="math notranslate nohighlight">\(U_a\)</span> implements some permutation on the set of input bit strings
<span class="math notranslate nohighlight">\(000,001,\ldots,111\)</span>. The corresponding quantum gate implements the
same permutation on the set of basis states
<span class="math notranslate nohighlight">\(|000\rangle,|001\rangle,\ldots,|111\rangle\)</span>.&nbsp;We&nbsp;obtained a
quantum circuit &nbsp;<span class="math notranslate nohighlight">\(U_a\)</span> acting on a register of <span class="math notranslate nohighlight">\(n\)</span> qubits that maps
a basis state <span class="math notranslate nohighlight">\(|x\rangle\)</span>&nbsp;to <span class="math notranslate nohighlight">\(|f(x)\rangle\)</span>. An example for
<span class="math notranslate nohighlight">\(f(x)=7x\pmod{15}\)</span> is shown below. Period finding algorithm requires
modular multiplication circuits <span class="math notranslate nohighlight">\(U_b\)</span> for
<span class="math notranslate nohighlight">\(b=a,a^2,a^4,\ldots,a^{2^p} \pmod{N}\)</span>, where <span class="math notranslate nohighlight">\(2^p\approx N^2\)</span>.</p>
<div class="line-block">
<div class="line"><img alt="image9" src="https://dal.objectstorage.open.softlayer.com/v1/AUTH_039c3bf6e6e54d76b8e66152e2f87877/images-classroom/shor-encodingo3tdoo4oaytd42t9.png" /></div>
<div class="line"><strong>some basis states representing integers modulo :math:`15`</strong></div>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
<div class="line-block">
<div class="line"><img alt="image10" src="https://dal.objectstorage.open.softlayer.com/v1/AUTH_039c3bf6e6e54d76b8e66152e2f87877/images-classroom/shor-u79r0hm5m0hot21emi.png" /></div>
<div class="line"><strong>Modular multiplication operator &nbsp;maps :math:`|xrangle` to :math:`|7x
pmod{15}rangle`</strong></div>
</div>
<p>&nbsp; &nbsp;This quantum circuit implements <span class="math notranslate nohighlight">\(U_7\)</span> (see <a class="reference external" href="http://arxiv.org/abs/1202.6614">Markov and Saeedi
2012</a>)</p>
<p>&nbsp;&nbsp;<img alt="image11" src="https://dal.objectstorage.open.softlayer.com/v1/AUTH_039c3bf6e6e54d76b8e66152e2f87877/images-classroom/multi7xmod159bozodtkjb9h33di.png" /></p>
</div>
<div class="section" id="controlled-operations-and-phase-estimation">
<h2><strong>﻿Controlled operations and phase estimation</strong>.﻿<a class="headerlink" href="#controlled-operations-and-phase-estimation" title="Permalink to this headline">¶</a></h2>
<p>Let <span class="math notranslate nohighlight">\(U=U_a\)</span> be the modular multiplication operator.&nbsp;At this point we
know how to construct a quantum circuit implementing&nbsp;<span class="math notranslate nohighlight">\(U\)</span> as well as
repeated squares of <span class="math notranslate nohighlight">\(U\)</span> such as <span class="math notranslate nohighlight">\(U^2,U^4,U^8\)</span>, etc. &nbsp;We also know
that eigenvalues of <span class="math notranslate nohighlight">\(U\)</span> reveal information about the period of <span class="math notranslate nohighlight">\(a\)</span>
modulo <span class="math notranslate nohighlight">\(N\)</span>. The final step is to measure the eigenvalues. For that we
shall need a controlled version of <span class="math notranslate nohighlight">\(U\)</span>.&nbsp;A controlled unitary operator
is a quantum analogue of classical conditional statements such as
if-then-else.&nbsp;We already saw examples of controlled quantum
gates<a class="reference external" href="../004-Quantum_Algorithms/061-Basic_Circuit_Identities_and_Larger_Circuits.html">earlier in the
tutorial</a>.&nbsp;In
general, suppose <span class="math notranslate nohighlight">\(U\)</span> is a quantum circuit acting on <span class="math notranslate nohighlight">\(n\)</span> qubits.&nbsp;A
controlled version of <span class="math notranslate nohighlight">\(U\)</span> &nbsp;is a unitary operator acting on a larger
system&nbsp;control+target, where control is a single qubit and target is a
register of <span class="math notranslate nohighlight">\(n\)</span> qubits.&nbsp;Controlled-<span class="math notranslate nohighlight">\(U\)</span> applies <span class="math notranslate nohighlight">\(U\)</span> to the target
register if the control qubit is <span class="math notranslate nohighlight">\(|1\rangle\)</span>&nbsp;state and does nothing
if the control qubit is <span class="math notranslate nohighlight">\(|0\rangle\)</span>.</p>
<div class="line-block">
<div class="line"><img alt="image12" src="https://dal.objectstorage.open.softlayer.com/v1/AUTH_039c3bf6e6e54d76b8e66152e2f87877/images-classroom/cont18osk7q79jzx8byb9.png" /></div>
<div class="line">Like their classical counterparts, controlled quantum operations are
used in almost any quantum algorithm.&nbsp;We note that if <span class="math notranslate nohighlight">\(U\)</span> can be
realized by a short quantum circuit then so does
controlled-<span class="math notranslate nohighlight">\(U\)</span>.&nbsp;Indeed, one can take the circuit realizing <span class="math notranslate nohighlight">\(U\)</span> and
replace each gate by its controlled version (with the same control
qubit).&nbsp;The main distinction from the classical if-then-else construct
&nbsp;is that the controlled qubit can be in a superposition of state
<span class="math notranslate nohighlight">\(\alpha|0\rangle +\beta|1\rangle\)</span>.&nbsp;One could say that in the
quantum world two branches of a conditional statement can be executed
“at the same time”. &nbsp;Consider now a special case when the target
register is prepared in some&nbsp;state <span class="math notranslate nohighlight">\(\psi\)</span> which is an eigenvector
of &nbsp;<span class="math notranslate nohighlight">\(U\)</span>, that is <span class="math notranslate nohighlight">\(U|\psi\rangle=e^{i\phi}
|\psi\rangle\)</span>.&nbsp;Then the only difference between the two branches
of the controlled-<span class="math notranslate nohighlight">\(U\)</span> operation&nbsp;is the phase shift <span class="math notranslate nohighlight">\(e^{i\phi}\)</span>.
In other words, the control qubit gets mapped from
&nbsp;<span class="math notranslate nohighlight">\(\alpha|0\rangle+\beta|1\rangle\)</span> to <span class="math notranslate nohighlight">\(\alpha|0\rangle
+e^{i\phi}\beta |1\rangle\)</span>, while&nbsp;the target register remains in
the state <span class="math notranslate nohighlight">\(\psi\)</span>.&nbsp;Thus we can describe that the action of
controlled-<span class="math notranslate nohighlight">\(U\)</span> on the composite&nbsp;system control+target by a
single-qubit phase shift gate <span class="math notranslate nohighlight">\(P\)</span>&nbsp;acting on the control qubit.</div>
</div>
<div class="line-block">
<div class="line"><img alt="image13" src="https://dal.objectstorage.open.softlayer.com/v1/AUTH_039c3bf6e6e54d76b8e66152e2f87877/images-classroom/cont22hp10kmu28146lxr.png" /></div>
</div>
<p>Below we focus on what happens with the control qubit only (keeping in
mind&nbsp;that it is part of the larger system control+target). &nbsp;We shall
measure the eigenvalue <span class="math notranslate nohighlight">\(e^{i\phi}\)</span> using a pair of phase estimation
circuits&nbsp;shown below.</p>
<div class="line-block">
<div class="line"><img alt="image14" src="https://dal.objectstorage.open.softlayer.com/v1/AUTH_039c3bf6e6e54d76b8e66152e2f87877/images-classroom/pejy6u84yb7ucpiudi.png" /></div>
</div>
<div class="line-block">
<div class="line">One can easily check that the probability of observing the measurement
outcome <span class="math notranslate nohighlight">\(0\)</span>&nbsp;is <span class="math notranslate nohighlight">\(0.5(1+\cos{(\phi)})\)</span> for the first circuit and
<span class="math notranslate nohighlight">\(0.5(1-\sin{(\phi)})\)</span> for the second circuit. &nbsp;One should keep in
mind that <span class="math notranslate nohighlight">\(P\)</span> represents the controlled-<span class="math notranslate nohighlight">\(U\)</span> operator, so the
circuit extracts information about the phase <span class="math notranslate nohighlight">\(\phi\)</span> by measuring
interference between two branches of controlled-<span class="math notranslate nohighlight">\(U\)</span> where one branch
accumulates a phase factor <span class="math notranslate nohighlight">\(e^{i\phi}\)</span> and the other branch
accumulates no phase. By repeating each circuit several time and
collecting the measurement statistics we&nbsp;can estimate the
probabilities which gives us an estimate <span class="math notranslate nohighlight">\(\phi\)</span>.&nbsp;For concreteness,
assume that we are willing to perform at most 100 measurements.&nbsp;Then
the statistical error in our estimate of <span class="math notranslate nohighlight">\(\phi\)</span> is roughly 10%.</div>
<div class="line">To factor a number <span class="math notranslate nohighlight">\(N\)</span> with 1,000 decimal digits the phase <span class="math notranslate nohighlight">\(\phi\)</span>
has to be estimated with a very high precision <span class="math notranslate nohighlight">\(\epsilon \sim 1/N^2
\sim 10^{-2000}\)</span>.&nbsp;To this end we shall perform the phase estimation
for a family of unitary operators <span class="math notranslate nohighlight">\(U^t\)</span>, where&nbsp;<span class="math notranslate nohighlight">\(t=1,2,4,8\)</span> etc. We
stop at <span class="math notranslate nohighlight">\(t=2^p\)</span> such that <span class="math notranslate nohighlight">\(2^p\approx 1/\epsilon\)</span>. Recall that
we can efficiently implement <span class="math notranslate nohighlight">\(U^t\)</span> for very large values of <span class="math notranslate nohighlight">\(t\)</span>
&nbsp;by classically computing <span class="math notranslate nohighlight">\(b=a^{t}\pmod{N}\)</span> and using the identity
<span class="math notranslate nohighlight">\(U^t=(U_a)^t=U_b\)</span>. Since all operators <span class="math notranslate nohighlight">\(U^t\)</span> have the same
eigenvector <span class="math notranslate nohighlight">\(\psi\)</span>, we can do all phase estimations&nbsp;with the same
target register (initialized in the eigenvector
<span class="math notranslate nohighlight">\(|\psi\rangle\)</span>).&nbsp;For simplicity, let us assume that the phase
estimations are performed sequentially&nbsp;in which case only one control
qubit is needed.&nbsp;The controlled-<span class="math notranslate nohighlight">\(U^2\)</span> operator gives rise to a phase
shift <span class="math notranslate nohighlight">\(P^2\)</span> by angle <span class="math notranslate nohighlight">\(2\phi\)</span>&nbsp;on the control qubit. Thus we can
estimate <span class="math notranslate nohighlight">\(2\phi\)</span> with a precision 10% &nbsp;by performing roughly 100
measurements. This gives an estimate of <span class="math notranslate nohighlight">\(\phi\)</span> &nbsp;with&nbsp;a precision
5%. &nbsp;More precisely, since the phase <span class="math notranslate nohighlight">\(\phi\)</span> lives on the unit
circuit, we get a pair of candidate angles <span class="math notranslate nohighlight">\(\phi'\)</span> and
<span class="math notranslate nohighlight">\(\phi''=\phi'+\pi\)</span> such that one of them approximates <span class="math notranslate nohighlight">\(\phi\)</span>
with a precision 5% and the other is very far from <span class="math notranslate nohighlight">\(\phi\)</span>
(approximately by <span class="math notranslate nohighlight">\(\pi\)</span>). &nbsp;However, we have already estimated
<span class="math notranslate nohighlight">\(\phi\)</span> itself with a precision 10%. This is enough to select one of
the candidate angles <span class="math notranslate nohighlight">\(\phi'\)</span> and <span class="math notranslate nohighlight">\(\phi''\)</span>. Applying this
argument inductively several times shows that estimating
&nbsp;<span class="math notranslate nohighlight">\(\phi,2\phi,\ldots,2^p\phi\)</span> with a constant precision (say,
10%) is enough to estimate&nbsp;<span class="math notranslate nohighlight">\(\phi\)</span> with a precision roughly
<span class="math notranslate nohighlight">\(2^{-p}\sim \epsilon\)</span>. Overall we would need&nbsp;approximately
<span class="math notranslate nohighlight">\(M=100\log_2{(1/\epsilon)}\sim 10^6\)</span> measurements which
translates&nbsp;to <span class="math notranslate nohighlight">\(10^6\)</span> controlled modular multiplication operators. In
general, <span class="math notranslate nohighlight">\(M\)</span> scales as <span class="math notranslate nohighlight">\(\log{(N)}\)</span> with some extra factors doubly
logarithmic in <span class="math notranslate nohighlight">\(N\)</span>. Since each controlled modular multiplication
operator requires a quantum circuit of size <span class="math notranslate nohighlight">\(\log^2{(N)}\)</span>, the
overall complexity of the factoring algorithm scales as
<span class="math notranslate nohighlight">\(\log^3{(N)}\sim d^3\)</span>.</div>
</div>
<p>We have not explained yet how to initialize the target register in the
eigenvector of <span class="math notranslate nohighlight">\(U\)</span>. Fortunately, all eigenvectors are equally good for
our purposes: we are not interested in any particular eigenvalue &nbsp;but
rather want to measure a random eigenvalue drawn from the uniform
distribution. Thus one can initialize the target register in an
arbitrary state that has equal weight on each eigenvector of <span class="math notranslate nohighlight">\(U\)</span>. For
example, one can choose the initial state as the basis vector
<span class="math notranslate nohighlight">\(|0\ldots01\rangle\)</span> encoding the integer <span class="math notranslate nohighlight">\(x=1\)</span>.</p>
<div class="line-block">
<div class="line"><br /></div>
<div class="line"><strong>Multi7x1Mod15</strong></div>
</div>
<a href="https://quantumexperience.ng.bluemix.net/qx/editor?codeId=858317af73c7a5ed31f676db5b15913f&sharedCode=true" target="_parent"><img src="https://dal.objectstorage.open.softlayer.com/v1/AUTH_42263efc45184c7ca4742512588a1942/codes/code-570b68405ba63ca75c724d3f40aaa614.png" style="width: 100%; max-width: 600px;"></a>
<a href="https://quantumexperience.ng.bluemix.net/qx/editor?codeId=858317af73c7a5ed31f676db5b15913f&sharedCode=true" target="_blank" style="text-align: right; display: block;">Open in composer</a><div class="line-block">
<div class="line"><br /></div>
<div class="line"><strong>Multi7x7Mod15</strong></div>
</div>
<a href="https://quantumexperience.ng.bluemix.net/qx/editor?codeId=c97d1b1f88e0615685200e6cd6d4b8d2&sharedCode=true" target="_parent"><img src="https://dal.objectstorage.open.softlayer.com/v1/AUTH_42263efc45184c7ca4742512588a1942/codes/code-4568159e2e0816fb088fec7ee697568a.png" style="width: 100%; max-width: 600px;"></a>
<a href="https://quantumexperience.ng.bluemix.net/qx/editor?codeId=c97d1b1f88e0615685200e6cd6d4b8d2&sharedCode=true" target="_blank" style="text-align: right; display: block;">Open in composer</a><div class="line-block">
<div class="line"><br /></div>
<div class="line"><strong>Multi7x4Mod15</strong></div>
</div>
<a href="https://quantumexperience.ng.bluemix.net/qx/editor?codeId=858317af73c7a5ed31f676db5b62695e&sharedCode=true" target="_parent"><img src="https://dal.objectstorage.open.softlayer.com/v1/AUTH_42263efc45184c7ca4742512588a1942/codes/code-d9c40f27d67d4bf722209faa34abcc28.png" style="width: 100%; max-width: 600px;"></a>
<a href="https://quantumexperience.ng.bluemix.net/qx/editor?codeId=858317af73c7a5ed31f676db5b62695e&sharedCode=true" target="_blank" style="text-align: right; display: block;">Open in composer</a><div class="line-block">
<div class="line"><br /></div>
<div class="line"><strong>Multi7x13Mod15</strong></div>
</div>
<a href="https://quantumexperience.ng.bluemix.net/qx/editor?codeId=858317af73c7a5ed31f676db5b9099fd&sharedCode=true" target="_parent"><img src="https://dal.objectstorage.open.softlayer.com/v1/AUTH_42263efc45184c7ca4742512588a1942/codes/code-c1908bfce53e5d26b810465dbb742499.png" style="width: 100%; max-width: 600px;"></a>
<a href="https://quantumexperience.ng.bluemix.net/qx/editor?codeId=858317af73c7a5ed31f676db5b9099fd&sharedCode=true" target="_blank" style="text-align: right; display: block;">Open in composer</a><div class="line-block">
<div class="line"><br /></div>
<div class="line"><strong>PhaseEstimationTgate</strong></div>
</div>
<a href="https://quantumexperience.ng.bluemix.net/qx/editor?codeId=0a1742807714ccbf73df68bbef062fae&sharedCode=true" target="_parent"><img src="https://dal.objectstorage.open.softlayer.com/v1/AUTH_42263efc45184c7ca4742512588a1942/codes/code-6d67a99a2c4c052189cdc290465cf383.png" style="width: 100%; max-width: 600px;"></a>
<a href="https://quantumexperience.ng.bluemix.net/qx/editor?codeId=0a1742807714ccbf73df68bbef062fae&sharedCode=true" target="_blank" style="text-align: right; display: block;">Open in composer</a></div>
</div>


        </div>

      <div class="clearer"></div>
    </div><div class="pagenation">
     <a id="button-prev" href="100-Quantum_Phase_Estimation.html" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--colored" role="botton" accesskey="P">
         <div class="pagenation-text">
            <span class="pagenation-direction">Previous</span>
            <div>Quantum Phase Estimation</div>
         </div>
     </a>
     <a id="button-next" href="../005-Quantum_Error_Correction/059-Quantum_Error_Correction.html" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--colored" role="botton" accesskey="N">
        <div class="pagenation-text">
            <span class="pagenation-direction">Next</span>
            <div>Quantum Error Correction</div>
        </div>
     </a>
        
        </main>
    </div>
  </body>
</html>